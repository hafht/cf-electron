This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
docs/
  MODULE-0.1-NOTES.md
  MODULE-1.1-INSTRUCTION.md
  MODULE-1.2-INSTRUCTION.md
  MODULE-1.3-WINDOW-INSTRUCTIONS.md
  OVERVIEW.md
  PRELOAD-SECURITY-CHECKLIST.md
  README.md
scripts/
  link-cf-electron.mjs
  unlink-cf-electron.mjs
  zip-source.mjs
src/
  config/
    appConfigModule.ts
    appConfigService.ts
    appConfigTypes.ts
    index.ts
  core/
    appLifecycle.ts
    coreTypes.ts
    createElectronApp.ts
  di/
    container.ts
  ipc/
    ipcChannels.ts
    ipcHandlerRegistry.ts
    ipcMainModule.ts
  preload/
    preloadApi.ts
    preloadEntry.ts
  window/
    index.ts
    windowMainModule.ts
    windowTypes.ts
  index.ts
.cursorrules
.gitignore
NAMING-CONVENTIONS.md
package.json
SESSION-CONTEXT-SUMMARY.md
tsconfig.json
vite.config.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="docs/MODULE-0.1-NOTES.md">
üìò MODULE 0.1 ‚Äì App Bootstrap & Lifecycle

Package: @creative-force/electron-core
Status: ‚úÖ DONE (Foundation)
Purpose: X∆∞∆°ng s·ªëng cho to√†n b·ªô Electron Framework

1Ô∏è‚É£ M·ª•c ti√™u Module 0.1 (ƒë√£ ƒë·∫°t)

Module 0.1 ch·ªãu tr√°ch nhi·ªám DUY NH·∫§T cho:

Kh·ªüi t·∫°o Electron app

Chu·∫©n h√≥a lifecycle

ƒêi·ªÅu ph·ªëi module

Cung c·∫•p DI container cho app & module

Sau Module 0.1, app kh√¥ng c√≤n tr·ª±c ti·∫øp qu·∫£n l√Ω Electron lifecycle.

2Ô∏è‚É£ Nh·ªØng g√¨ ƒê√É L√ÄM (In Scope)
2.1 Public API (Freeze v1)
createElectronApp(options: CreateElectronAppOptions): Promise<void>


appId b·∫Øt bu·ªôc

modules optional

Ch·ªâ c√≥ 1 entry point duy nh·∫•t

2.2 Module Contract
export interface ElectronModule {
  register(container: AppContainer): void;
  start?(): Promise<void>;
  stop?(): Promise<void>;
}


register() ch·∫°y sync, tr∆∞·ªõc app.whenReady

start() ch·∫°y sau whenReady

stop() ch·∫°y khi app quit

App kh√¥ng hook Electron event

2.3 Dependency Injection

Framework t·∫°o 1 DI container / app

Container ƒë∆∞·ª£c truy·ªÅn v√†o module qua register()

App kh√¥ng import DI library

Framework expose AppContainer type alias

2.4 Electron Lifecycle Handling

Centralized trong electron-core

Handle:

app.whenReady

before-quit

stop() g·ªçi theo th·ª© t·ª± ng∆∞·ª£c

Graceful shutdown (no zombie process)

2.5 Error Handling (t·ªëi thi·ªÉu)

Catch error trong:

register()

start()

stop()

Log r√µ module l·ªói

Fail fast khi critical

2.6 Logging (t·∫°m th·ªùi)

D√πng console

Prefix [electron-core]

Ch·ªâ ƒë·ªÉ debug bootstrap

2.7 Developer Experience

App entry < 20 d√≤ng

Kh√¥ng c·∫ßn hi·ªÉu Electron lifecycle

Module d·ªÖ vi·∫øt, d·ªÖ test

AI c√≥ th·ªÉ generate module skeleton ƒë√∫ng chu·∫©n

3Ô∏è‚É£ Nh·ªØng g√¨ C·ªê √ù CH∆ØA L√ÄM (Out of Scope)

‚ùå IPC / Preload
‚ùå Window management
‚ùå Config loader
‚ùå Logger module
‚ùå Auth
‚ùå External service manager
‚ùå Telemetry / analytics

Module 0.1 = x∆∞∆°ng s·ªëng, kh√¥ng ph·∫£i feature module

4Ô∏è‚É£ Quy ∆∞·ªõc & Nguy√™n t·∫Øc ƒê√É CH·ªêT
4.1 Architectural Rules

App kh√¥ng g·ªçi Electron lifecycle API

Module kh√¥ng hook Electron event

Module kh√¥ng g·ªçi module kh√°c tr·ª±c ti·∫øp

Kh√¥ng global mutable state

4.2 DI Rules

App kh√¥ng import inversify

Ch·ªâ d√πng AppContainer

Framework c√≥ quy·ªÅn ƒë·ªïi DI implementation

5Ô∏è‚É£ Known Limitations (Ch·∫•p nh·∫≠n ·ªü v1)

Logging ƒë∆°n gi·∫£n

Ch∆∞a c√≥ test automation

Ch∆∞a support restart module

Ch∆∞a c√≥ async register

‚û° S·∫Ω x·ª≠ l√Ω ·ªü module / phase sau

6Ô∏è‚É£ Module Dependency Graph (t·∫°m)
electron-core (0.1)
   ‚Üë
   ‚îú‚îÄ electron-ipc (1.1)
   ‚îú‚îÄ electron-config (1.2)
   ‚îú‚îÄ electron-logger (2.1)
   ‚îú‚îÄ electron-service-manager (2.2)
   ‚îî‚îÄ electron-auth (3.1)

7Ô∏è‚É£ C√°c Module TI·∫æP THEO (Roadmap)
üîú Module 1.1 ‚Äì IPC & Preload Standardization

Priority: HIGH

Typed IPC

Central IPC registry

Single preload API (window.api)

Renderer kh√¥ng import ipcRenderer

üîú Module 1.2 ‚Äì Config Management

Priority: HIGH

Config schema

Validate on startup

Immutable config

üîú Module 2.1 ‚Äì Logging

Priority: MEDIUM

Central logger

Structured log

Context-based logging

üîú Module 2.2 ‚Äì Service / Process Manager

Priority: MEDIUM

Dotnet / exe service lifecycle

Health check

Graceful shutdown

üîú Module 3.1 ‚Äì Authentication

Priority: HIGH (Beta App)

OAuth PKCE

External browser

Token management

8Ô∏è‚É£ Instruction cho b∆∞·ªõc ti·∫øp theo
B·∫ÆT ƒê·∫¶U MODULE 1.1 KHI:

Module 0.1 ƒë√£ ƒë∆∞·ª£c:

ch·∫°y trong integration app

review & approve

App side ƒë√£ quen v·ªõi ElectronModule contract

KH√îNG b·∫Øt ƒë·∫ßu module m·ªõi khi:

Module tr∆∞·ªõc ch∆∞a d√πng th·ª±c t·∫ø

API ch∆∞a ·ªïn ƒë·ªãnh

DX ch∆∞a ƒë∆∞·ª£c validate

9Ô∏è‚É£ Guiding Principle (NH·∫ÆC L·∫†I)

Framework th√†nh c√¥ng khi app dev kh√¥ng ph·∫£i suy nghƒ© v·ªÅ framework

üìå File n√†y l√† reference ‚Äì kh√¥ng s·ª≠a t√πy ti·ªán
üìå M·ªçi breaking change ph·∫£i bump MAJOR
</file>

<file path="docs/MODULE-1.1-INSTRUCTION.md">
üìò MODULE-1.1-INSTRUCTIONS.md

Module: IPC & Preload Standardization
Depends on: Module 0.1
Priority: HIGH

Check `PRELOAD-SECURITY-CHECKLIST.md` ƒë·ªÉ bi·∫øt rules khi l√†m vi·ªác v·ªõi preload.

1. M·ª•c ti√™u Module 1.1

Chu·∫©n h√≥a c√°ch giao ti·∫øp gi·ªØa Renderer ‚Üî Main b·∫±ng IPC, v·ªõi c√°c y√™u c·∫ßu:

Secure

Typed

Consistent

D·ªÖ debug

D·ªÖ m·ªü r·ªông

IPC ƒë∆∞·ª£c xem l√† Public API c·ªßa Desktop App.

2. Problem c·∫ßn gi·∫£i quy·∫øt

Hi·ªán t·∫°i (trong c√°c app c≈©):

IPC string r·∫£i r√°c

Kh√¥ng c√≥ contract r√µ r√†ng

Renderer g·ªçi ipcRenderer tr·ª±c ti·∫øp

Preload expose tu·ª≥ ti·ªán

Kh√≥ refactor, d·ªÖ bug ng·∫ßm

3. Nguy√™n t·∫Øc thi·∫øt k·∫ø (B·∫ÆT BU·ªòC)
3.1 IPC l√† contract, kh√¥ng ph·∫£i implementation

IPC channel = API name

Kh√¥ng thay ƒë·ªïi tu·ª≥ ti·ªán

Breaking IPC = bump major

3.2 Renderer KH√îNG bi·∫øt Electron

Renderer:

window.api.auth.login()


Renderer:
‚ùå kh√¥ng import ipcRenderer
‚ùå kh√¥ng import electron

3.3 Preload l√† boundary duy nh·∫•t

To√†n b·ªô IPC ph·∫£i ƒëi qua preload

Preload expose 1 object duy nh·∫•t

4. Scope Module 1.1
In scope

IPC registry

Typed IPC

Preload expose API

IPC handler lifecycle

Out of scope

Business logic

Auth flow

Permission system ph·ª©c t·∫°p

5. API shape (freeze v1 ‚Äì proposal)
Preload API
window.api = {
  app: {
    getVersion(): Promise<string>;
  },
  auth: {
    login(): Promise<void>;
    logout(): Promise<void>;
  }
};


ƒê√¢y ch·ªâ l√† v√≠ d·ª• ‚Äì structure ph·∫£i domain-based

6. Ki·∫øn tr√∫c ƒë·ªÅ xu·∫•t
Renderer
  ‚Üì (window.api)
Preload
  ‚Üì (ipcRenderer.invoke)
IPC Registry (Main)
  ‚Üì
Module Handler

7. C√°c th√†nh ph·∫ßn c·∫ßn x√¢y d·ª±ng
7.1 IPC Registry (Main)

Tr√°ch nhi·ªám

Central register IPC channels

Bind handler v·ªõi module

Log & catch error

Instruction

Kh√¥ng ƒëƒÉng k√Ω IPC tr·ª±c ti·∫øp trong module

M·ªçi IPC ƒëi qua registry

7.2 IPC Handler Interface
export interface IpcHandler {
  register(): void;
}


Module c√≥ th·ªÉ cung c·∫•p nhi·ªÅu handler

Handler kh√¥ng ch·ª©a business logic n·∫∑ng

7.3 Preload Exposer

Tr√°ch nhi·ªám

Expose API an to√†n

Kh√¥ng leak Electron API

Validate input (basic)

8. Th·ª© t·ª± implement (B·∫ÆT BU·ªòC)

Define IPC naming convention

Build IPC registry (main)

Build preload API shape

Connect preload ‚Üî registry

Example IPC: app.getVersion

Write doc + example usage

9. Definition of Done (DoD)

Module 1.1 ƒë∆∞·ª£c coi l√† DONE khi:

 Renderer kh√¥ng import Electron

 Preload expose 1 API duy nh·∫•t

 IPC channel centralized

 C√≥ example IPC end-to-end

 C√≥ documentation

 C√≥ app demo ch·∫°y th·∫≠t

10. Nh·ªØng ƒëi·ªÅu C·∫§M l√†m

‚ùå IPC string r·∫£i r√°c

‚ùå Renderer g·ªçi ipcRenderer

‚ùå Preload expose raw Electron API

‚ùå Business logic trong IPC handler

11. Output mong ƒë·ª£i

Sau Module 1.1:

Framework c√≥ communication backbone

Module sau (Auth, Service Manager) c√≥ th·ªÉ build clean

App dev vi·∫øt IPC kh√¥ng s·ª£ v·ª°

12. Note cho AI / Contributor

N·∫øu generate code:

Lu√¥n theo naming convention

Kh√¥ng t·ª± √Ω th√™m feature ngo√†i scope

∆Øu ti√™n clarity h∆°n cleverness

13. Next Modules (Preview)

Module 1.2 ‚Äì Config Management

Module 2.1 ‚Äì Logging

Module 2.2 ‚Äì Service Manager

üìå File n√†y l√† instruction, kh√¥ng ph·∫£i discussion
üìå M·ªçi thay ƒë·ªïi ph·∫£i c√≥ l√Ω do & review
</file>

<file path="docs/MODULE-1.2-INSTRUCTION.md">
üìò MODULE-1.2-INSTRUCTIONS.md

Module: Configuration Management
Depends on:

Module 0.1 (App Bootstrap)

Module 1.1 (IPC ‚Äì request/response)

1Ô∏è‚É£ M·ª•c ti√™u Module 1.2

Chu·∫©n h√≥a c√°ch define ‚Äì load ‚Äì validate ‚Äì consume config cho desktop app.

Config ph·∫£i:

C√≥ schema

Validate khi app start

Read-only

Consistent gi·ªØa c√°c app

2Ô∏è‚É£ Problem hi·ªán t·∫°i (t·ª´ app c≈©)

Config n·∫±m r·∫£i r√°c:

env

json

global variable

Kh√¥ng c√≥ schema

Sai config ‚Üí l·ªói runtime mu·ªôn

M·ªói app x·ª≠ l√Ω config kh√°c nhau

3Ô∏è‚É£ Nguy√™n t·∫Øc thi·∫øt k·∫ø (B·∫ÆT BU·ªòC)
3.1 Config l√† input c·ªßa app, kh√¥ng ph·∫£i state

Config:

read-only

kh√¥ng mutate

Kh√¥ng store token / runtime data

3.2 Fail fast

Config sai ‚Üí app kh√¥ng start

Kh√¥ng:

fallback ng·∫ßm

default magic

3.3 Config ph·∫£i typed

Kh√¥ng any

Kh√¥ng string-based access

4Ô∏è‚É£ Scope Module 1.2
In scope

Config schema

Load config (env + file)

Validate on startup

Expose config qua DI

Out of scope

Secret management ph·ª©c t·∫°p

Dynamic config reload

Feature flag system

5Ô∏è‚É£ Ki·∫øn tr√∫c ƒë·ªÅ xu·∫•t (high-level)
Config Schema
   ‚Üì
Config Loader
   ‚Üì
Validation
   ‚Üì
AppContainer (DI)
   ‚Üì
Modules consume config

6Ô∏è‚É£ API Shape (proposal ‚Äì freeze v1)
6.1 Config schema (app-defined)
export interface AppConfig {
  env: 'dev' | 'prod';
  apiBaseUrl: string;
  enableDebug: boolean;
}


üëâ Schema thu·ªôc app, kh√¥ng thu·ªôc framework

6.2 Framework expose Config Service
export interface ConfigService<T> {
  get(): Readonly<T>;
}

7Ô∏è‚É£ App usage (target DX)
createElectronApp({
  appId: 'lhapp-beta',
  config: {
    env: 'dev',
    apiBaseUrl: 'https://api.example.com',
    enableDebug: true
  },
  modules: [...]
});


Trong module:

const config = container.get(ConfigService).get();

8Ô∏è‚É£ Th·ª© t·ª± implement Module 1.2

Define ConfigService interface

Build config loader

Validate config at app start

Bind config v√†o DI container

Write minimal doc + example

9Ô∏è‚É£ Nh·ªØng ƒëi·ªÅu C·∫§M l√†m

‚ùå Global process.env access trong module
‚ùå Mutate config
‚ùå Config n·∫±m r·∫£i r√°c
‚ùå Silent default

10Ô∏è‚É£ Definition of Done ‚Äì Module 1.2

 App kh√¥ng start n·∫øu config sai

 Config typed end-to-end

 Module access config qua DI

 Kh√¥ng module n√†o ƒë·ªçc process.env tr·ª±c ti·∫øp

 C√≥ doc & example
</file>

<file path="docs/MODULE-1.3-WINDOW-INSTRUCTIONS.md">
# MODULE-1.3-WINDOW-INSTRUCTIONS.md

## Module: Window (Main Process)
**Phase:** 1 ‚Äì Communication & Control  
**Depends on:**  
- Module 0.1 ‚Äì App Bootstrap  
- Module 1.1 ‚Äì IPC (Request/Response)  
- Module 1.2 ‚Äì Configuration Management  

---

## 1. Purpose

The Window module is responsible for creating and managing the Electron `BrowserWindow`.

This module enables the application to:
- Run end-to-end (main ‚Üí preload ‚Üí renderer)
- Standardize window creation
- Enforce a secure baseline
- Remain minimal and extensible

> The Window module is infrastructure, not business logic.

---

## 2. Scope

### In Scope
- Create a single main `BrowserWindow`
- Attach preload script
- Load renderer (development / production)
- Handle window lifecycle (create / destroy)

### Out of Scope
- Multi-window management
- Window registry
- Menu / Tray
- Shortcuts
- Window state persistence
- Business IPC logic

---

## 3. Design Principles

### 3.1 Infrastructure Only
- No business logic
- No renderer framework knowledge (Angular / React / etc.)
- No IPC handlers

### 3.2 App-Owned Renderer Entry
- Framework does not hardcode URLs or file paths
- App decides dev/prod renderer entry

### 3.3 Security First
All windows created by this module MUST:
- Use `contextIsolation: true`
- Disable `nodeIntegration`
- Enable `sandbox`
- Avoid exposing Electron APIs to renderer

---

## 4. Public API

### 4.1 WindowOptions

```ts
export interface WindowOptions {
  preloadPath: string;

  load: {
    devUrl?: string;
    prodFile?: string;
  };

  browserWindow?: Electron.BrowserWindowConstructorOptions;
}
```

---

### 4.2 WindowMainModule

```ts
new WindowMainModule(options: WindowOptions)
```

Implements the `ElectronModule` interface and participates in the app lifecycle.

---

## 5. Lifecycle

```
createElectronApp()
   ‚Üì
app.whenReady()
   ‚Üì
WindowMainModule.start()
   ‚Üì
BrowserWindow created
   ‚Üì
preload attached
   ‚Üì
renderer loaded
```

---

## 6. Usage Example (App Side)

```ts
import { createElectronApp } from '@creative-force/electron-core';
import { WindowMainModule } from '@creative-force/electron-window';
import { ConfigModule } from '@creative-force/electron-config';
import { z } from 'zod';

const AppConfigSchema = z.object({
  env: z.enum(['dev', 'prod'])
});

const isDev = process.env.NODE_ENV === 'development';

createElectronApp({
  appId: 'cf-window-demo',
  modules: [
    new ConfigModule({
      schema: AppConfigSchema,
      value: { env: isDev ? 'dev' : 'prod' }
    }),

    new WindowMainModule({
      preloadPath: require.resolve('../preload/preloadEntry.js'),
      load: {
        devUrl: isDev ? 'http://localhost:5173' : undefined,
        prodFile: !isDev
          ? require.resolve('../renderer/index.html')
          : undefined
      }
    })
  ]
});
```

---

## 7. Preload Example

```ts
import { contextBridge } from 'electron';

contextBridge.exposeInMainWorld('api', {
  ping: () => 'pong'
});
```

---

## 8. Renderer Test

```ts
console.log(window.api.ping());
```

---

## 9. Security Checklist

- ‚úì contextIsolation enabled
- ‚úì nodeIntegration disabled
- ‚úì sandbox enabled
- ‚úì No Electron APIs exposed
- ‚úì Window destroyed on shutdown

---

## 10. Anti-patterns

- Creating BrowserWindow outside Window module
- Hardcoding renderer URLs in framework
- Exposing Electron APIs in preload
- Business logic inside Window module

---

## 11. Definition of Done

- App runs in dev and prod
- Preload executes correctly
- Renderer isolated from Electron
- Naming conventions followed
- No unnecessary abstraction

---

## Guiding Principle

> Window is infrastructure, not business.
</file>

<file path="docs/OVERVIEW.md">
1. M·ª•c ti√™u c·ªßa CF-ELECTRON

CF-ELECTRON l√† internal Electron framework d√πng l√†m basement cho c√°c desktop app c·ªßa team.

Framework n√†y:

Chu·∫©n h√≥a Electron main process

Chu·∫©n h√≥a c√°ch module ho·∫°t ƒë·ªông

Gi·∫£m duplicate code gi·ªØa nhi·ªÅu app

TƒÉng t·ªëc ph√°t tri·ªÉn & debug

L√† n·ªÅn t·∫£ng cho c√°c module business ph√≠a sau

CF-ELECTRON KH√îNG ph·∫£i app, KH√îNG c√≥ UI, KH√îNG x·ª≠ l√Ω business tr·ª±c ti·∫øp.

2. Nguy√™n t·∫Øc ki·∫øn tr√∫c (ƒë√£ ch·ªët)

Framework ‚â† App

App ch·ªâ:

compose module

define business

Framework:

qu·∫£n l√Ω lifecycle

cung c·∫•p h·∫° t·∫ßng

Boundary r√µ r√†ng:

App kh√¥ng g·ªçi Electron lifecycle

App kh√¥ng bi·∫øt framework d√πng DI g√¨

Renderer kh√¥ng import Electron API

3. C·∫•u tr√∫c th∆∞ m·ª•c hi·ªán t·∫°i
cf-electron/
‚îú‚îÄ src/                    # Source code (TypeScript)
‚îÇ  ‚îú‚îÄ app/                 # App bootstrap & lifecycle
‚îÇ  ‚îÇ  ‚îú‚îÄ createElectronApp.ts
‚îÇ  ‚îÇ  ‚îú‚îÄ lifecycle.ts
‚îÇ  ‚îÇ  ‚îî‚îÄ types.ts
‚îÇ  ‚îÇ
‚îÇ  ‚îú‚îÄ di/                  # Dependency Injection
‚îÇ  ‚îÇ  ‚îî‚îÄ container.ts
‚îÇ  ‚îÇ
‚îÇ  ‚îî‚îÄ index.ts             # Public entry
‚îÇ
‚îú‚îÄ dist/                   # Build output (CJS + d.ts)
‚îÇ
‚îú‚îÄ docs/                   # Documentation
‚îÇ  ‚îú‚îÄ MODULE-0.1-NOTES.md
‚îÇ  ‚îî‚îÄ MODULE-1.1-INSTRUCTIONS.md
‚îÇ
‚îú‚îÄ scripts/                # Dev scripts (symlink, tooling)
‚îú‚îÄ package.json
‚îú‚îÄ tsconfig.json
‚îî‚îÄ vite.config.ts

4. C√°ch framework ho·∫°t ƒë·ªông (high-level)
App start
  ‚Üì
createElectronApp()
  ‚Üì
Create DI container
  ‚Üì
Module.register()
  ‚Üì
Electron app.whenReady()
  ‚Üì
Module.start()
  ‚Üì
App running
  ‚Üì
App quit
  ‚Üì
Module.stop()


Framework ƒëi·ªÅu ph·ªëi t·∫•t c·∫£, app ch·ªâ khai b√°o module.

5. Tr·∫°ng th√°i hi·ªán t·∫°i
‚úÖ Ho√†n th√†nh

Module 0.1 ‚Äì App Bootstrap & Lifecycle

‚è≠Ô∏è Ti·∫øp theo

Module 1.1 ‚Äì IPC & Preload Standardization

6. C√°ch dev ti·∫øp theo n√™n l√†m

Kh√¥ng s·ª≠a Module 0.1 tr·ª´ khi c·∫ßn thi·∫øt

B·∫Øt ƒë·∫ßu Module 1.1 theo instruction

Vi·∫øt docs song song v·ªõi code

Module m·ªõi ph·∫£i:

d√πng ƒë∆∞·ª£c ngay

c√≥ example

kh√¥ng ph√° DX

7. Guiding Principle

Framework th√†nh c√¥ng khi app dev kh√¥ng c·∫ßn hi·ªÉu framework internals
</file>

<file path="docs/PRELOAD-SECURITY-CHECKLIST.md">
üîê PRELOAD SECURITY CHECKLIST

Scope: Electron Preload (Framework)
Applies to: All desktop apps using CF-ELECTRON
Priority: CRITICAL

0Ô∏è‚É£ M·ª•c ti√™u c·ªßa Preload

Preload l√† security boundary gi·ªØa:

Untrusted Renderer (web-like)

Trusted Main Process (Node / OS access)

‚ùó N·∫øu preload sai ‚Üí app m·∫•t to√†n b·ªô security guarantee.

1Ô∏è‚É£ Nguy√™n t·∫Øc c·ªët l√µi (MUST UNDERSTAND)

Renderer = untrusted

Preload = gatekeeper

Main = privileged

üëâ Renderer KH√îNG ƒë∆∞·ª£c:

Access Node.js API

Access Electron API

Access OS / filesystem

2Ô∏è‚É£ Electron BrowserWindow Security Flags (B·∫ÆT BU·ªòC)
‚òê 2.1 contextIsolation: true
new BrowserWindow({
  webPreferences: {
    contextIsolation: true
  }
});


‚ùå KH√îNG BAO GI·ªú:

contextIsolation: false

‚òê 2.2 nodeIntegration: false
nodeIntegration: false


‚ùå Renderer kh√¥ng ƒë∆∞·ª£c d√πng Node

‚òê 2.3 enableRemoteModule: false
enableRemoteModule: false


‚ùå remote l√† legacy + insecure

3Ô∏è‚É£ Preload API Exposure Rules (C·ª∞C K·ª≤ QUAN TR·ªåNG)
‚òê 3.1 Ch·ªâ expose 1 object duy nh·∫•t
contextBridge.exposeInMainWorld('api', api);


‚ùå KH√îNG:

exposeInMainWorld('fs', fs)
exposeInMainWorld('electron', electron)

‚òê 3.2 Kh√¥ng expose function raw

‚ùå SAI:

window.api = ipcRenderer.invoke;


‚úÖ ƒê√öNG:

window.api = {
  app: {
    getVersion: () => ipc.invoke('app:getVersion')
  }
};

‚òê 3.3 API ph·∫£i domain-based
window.api = {
  app: {},
  auth: {},
  services: {}
};


‚ùå Kh√¥ng flat API:

window.api.login()

4Ô∏è‚É£ IPC Channel Security
‚òê 4.1 Kh√¥ng expose channel name tr·ª±c ti·∫øp

‚ùå Renderer:

ipcRenderer.invoke('auth:login');


‚úÖ Renderer:

window.api.auth.login();

‚òê 4.2 IPC channel naming convention
domain:action


V√≠ d·ª•:

app:getVersion

auth:login

service:start

‚òê 4.3 Kh√¥ng cho renderer subscribe IPC tu·ª≥ √Ω

‚ùå KH√îNG expose:

ipcRenderer.on(...)


N·∫øu c·∫ßn event:

Preload wrap l·∫°i

Control event name

5Ô∏è‚É£ Input Validation (Basic nh∆∞ng B·∫ÆT BU·ªòC)
‚òê 5.1 Validate input ·ªü preload (basic)
login(username: string) {
  if (typeof username !== 'string') {
    throw new Error('Invalid input');
  }
}


‚ùå Kh√¥ng tin renderer

‚òê 5.2 Kh√¥ng pass object raw xu·ªëng main

‚ùå SAI:

invoke('task:create', payload);


‚úÖ T·ªêT:

invoke('task:create', {
  id: payload.id,
  type: payload.type
});

6Ô∏è‚É£ Error Handling & Leakage
‚òê 6.1 Kh√¥ng leak error stack OS / Node

‚ùå KH√îNG:

throw err;


‚úÖ N√äN:

throw new Error('Operation failed');


(Main process log chi ti·∫øt)

‚òê 6.2 Promise rejection ph·∫£i ƒë∆∞·ª£c handle
return ipc.invoke(...).catch(() => {
  throw new Error('IPC error');
});

7Ô∏è‚É£ No Shared Mutable State
‚òê 7.1 Kh√¥ng store state trong preload

‚ùå KH√îNG:

let token;


Preload:

Stateless

Proxy-only

8Ô∏è‚É£ Explicit Allowlist (KHUY·∫æN NGH·ªä)
‚òê 8.1 Ch·ªâ expose API ƒë√£ ƒë·ªãnh nghƒ©a
const api = {
  app: {...},
  auth: {...}
};


‚ùå Kh√¥ng dynamic expose:

api[moduleName] = handler;

9Ô∏è‚É£ Dev vs Prod Behavior
‚òê 9.1 Kh√¥ng relax security v√¨ DEV

‚ùå KH√îNG:

if (dev) enableNodeIntegration();


Security flags ph·∫£i gi·ªëng nhau ·ªü DEV & PROD

10Ô∏è‚É£ Testing & Review Checklist
‚òê 10.1 Renderer kh√¥ng access ƒë∆∞·ª£c Node
typeof require === 'undefined'

‚òê 10.2 Renderer kh√¥ng access ƒë∆∞·ª£c Electron
typeof window.process === 'undefined'

‚òê 10.3 Only expected API exists
Object.keys(window.api)

11Ô∏è‚É£ Anti-patterns (C·∫§M TUY·ªÜT ƒê·ªêI)

‚ùå nodeIntegration: true
‚ùå contextIsolation: false
‚ùå expose ipcRenderer
‚ùå expose fs, path, process
‚ùå dynamic IPC channel
‚ùå preload ch·ª©a business logic

12Ô∏è‚É£ Quick Audit Script (Manual)

Trong DevTools (Renderer):

window.require
window.process
window.electron


üëâ T·∫•t c·∫£ ph·∫£i l√† undefined

13Ô∏è‚É£ Guiding Principle (NH·ªö K·ª∏)

Preload kh√¥ng ph·∫£i ti·ªán l·ª£i cho dev,
m√† l√† tuy·∫øn ph√≤ng th·ªß cu·ªëi c√πng cho app

14Ô∏è‚É£ Status & Ownership

Preload security rules freeze t·ª´ Module 1.1

M·ªçi thay ƒë·ªïi:

c·∫ßn review

c·∫ßn doc

c·∫ßn reason r√µ r√†ng

üìå Checklist n√†y d√πng cho PR review ‚Äì kh√¥ng tranh lu·∫≠n trong code
üìå N·∫øu nghi ng·ªù ‚Üí ch·ªçn ph∆∞∆°ng √°n an to√†n h∆°n
</file>

<file path="docs/README.md">
# CF-Electron Framework Documentation

ƒê√¢y l√† th∆∞ m·ª•c ch·ª©a t·∫•t c·∫£ documentation, engineering notes, v√† instructions cho CF-Electron framework.

## üìö T√†i li·ªáu ch√≠nh

### [OVERVIEW.md](./OVERVIEW.md)
**T√†i li·ªáu t·ªïng quan v·ªÅ framework**

- M·ª•c ti√™u v√† nguy√™n t·∫Øc ki·∫øn tr√∫c
- C·∫•u tr√∫c th∆∞ m·ª•c project
- C√°ch framework ho·∫°t ƒë·ªông (high-level)
- Tr·∫°ng th√°i hi·ªán t·∫°i v√† roadmap
- Development guidelines

**ƒê·ªçc file n√†y tr∆∞·ªõc** khi b·∫Øt ƒë·∫ßu l√†m vi·ªác v·ªõi framework ho·∫∑c khi c·∫ßn hi·ªÉu t·ªïng quan v·ªÅ ki·∫øn tr√∫c.

### [MODULE-0.1-NOTES.md](./MODULE-0.1-NOTES.md)
**Documentation cho Module 0.1 - App Bootstrap & Lifecycle**

Module n√†y l√† x∆∞∆°ng s·ªëng c·ªßa framework, ch·ªãu tr√°ch nhi·ªám:
- Kh·ªüi t·∫°o Electron app
- Chu·∫©n h√≥a lifecycle (register ‚Üí start ‚Üí stop)
- ƒêi·ªÅu ph·ªëi modules
- Cung c·∫•p DI container

**N·ªôi dung bao g·ªìm:**
- M·ª•c ti√™u v√† scope c·ªßa module
- Public API v√† Module Contract
- Dependency Injection setup
- Electron lifecycle handling
- Error handling v√† logging
- Known limitations
- Roadmap cho c√°c module ti·∫øp theo

**ƒê·ªçc file n√†y** khi:
- C·∫ßn hi·ªÉu c√°ch app bootstrap ho·∫°t ƒë·ªông
- Vi·∫øt module m·ªõi c·∫ßn implement lifecycle
- Debug issues li√™n quan ƒë·∫øn startup/shutdown
- Planning module ti·∫øp theo

## üìã C·∫•u tr√∫c Documentation

```
docs/
‚îú‚îÄ‚îÄ README.md              # File n√†y - Index c·ªßa t·∫•t c·∫£ docs
‚îú‚îÄ‚îÄ OVERVIEW.md            # T·ªïng quan framework
‚îî‚îÄ‚îÄ MODULE-*.md            # Documentation cho t·ª´ng module
    ‚îú‚îÄ‚îÄ MODULE-0.1-NOTES.md
    ‚îú‚îÄ‚îÄ MODULE-1.1-*.md    # (S·∫Ω c√≥ trong t∆∞∆°ng lai)
    ‚îî‚îÄ‚îÄ ...
```

## üîç C√°ch s·ª≠ d·ª•ng Documentation

### Khi b·∫Øt ƒë·∫ßu project m·ªõi
1. ƒê·ªçc `OVERVIEW.md` ƒë·ªÉ hi·ªÉu ki·∫øn tr√∫c t·ªïng th·ªÉ
2. ƒê·ªçc `MODULE-0.1-NOTES.md` ƒë·ªÉ hi·ªÉu lifecycle v√† c√°ch vi·∫øt module

### Khi implement feature m·ªõi
1. Ki·ªÉm tra `OVERVIEW.md` ƒë·ªÉ ƒë·∫£m b·∫£o kh√¥ng vi ph·∫°m nguy√™n t·∫Øc
2. ƒê·ªçc documentation c·ªßa module li√™n quan
3. Xem roadmap trong `MODULE-0.1-NOTES.md` ƒë·ªÉ bi·∫øt module n√†o ƒëang ƒë∆∞·ª£c plan

### Khi debug ho·∫∑c fix bug
1. ƒê·ªçc documentation c·ªßa module c√≥ v·∫•n ƒë·ªÅ
2. Ki·ªÉm tra known limitations
3. Xem implementation notes trong module docs

## üìù Quy ∆∞·ªõc vi·∫øt Documentation

- **Module docs** (`MODULE-*.md`): Ghi l·∫°i implementation notes, design decisions, v√† instructions cho t·ª´ng module
- **Status**: ƒê√°nh d·∫•u r√µ r√†ng module ƒë√£ ho√†n th√†nh (‚úÖ) hay ƒëang plan (üîú)
- **Breaking changes**: Ph·∫£i bump MAJOR version v√† update docs
- **File reference**: Kh√¥ng s·ª≠a t√πy ti·ªán, m·ªçi thay ƒë·ªïi ph·∫£i c√≥ l√Ω do r√µ r√†ng

## üöÄ Module Roadmap

Xem chi ti·∫øt trong `MODULE-0.1-NOTES.md` section 7Ô∏è‚É£:

- **Module 1.1** - IPC & Preload Standardization (HIGH priority)
- **Module 1.2** - Config Management (HIGH priority)
- **Module 2.1** - Logging (MEDIUM priority)
- **Module 2.2** - Service/Process Manager (MEDIUM priority)
- **Module 3.1** - Authentication (HIGH priority for Beta App)

## üí° L∆∞u √Ω

- T·∫•t c·∫£ documentation ƒë∆∞·ª£c vi·∫øt song song v·ªõi code
- Documentation l√† source of truth cho architecture decisions
- Khi c√≥ thay ƒë·ªïi ki·∫øn tr√∫c, ph·∫£i update docs tr∆∞·ªõc ho·∫∑c c√πng l√∫c v·ªõi code
- AI/Cursor s·∫Ω ƒë·ªçc docs n√†y ƒë·ªÉ hi·ªÉu context v√† ƒë∆∞a ra suggestions ph√π h·ª£p
</file>

<file path="scripts/link-cf-electron.mjs">
import fs from 'fs';
import path from 'path';
import process from 'process';
import { fileURLToPath } from 'url';

function getArg(name) {
  const index = process.argv.indexOf(name);
  return index !== -1 ? process.argv[index + 1] : null;
}

// Get workspace folder (parent directory of scripts folder, which is cf-electron)
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const frameworkFolder = path.resolve(__dirname, '..'); // This is cf-electron folder
const workspaceFolder = path.resolve(frameworkFolder, '..'); // This is test/ folder

// Try to get paths from args, env, or use defaults
let frameworkPath =
  getArg('--framework') || process.env.CF_ELECTRON_FRAMEWORK;
let clientPath = getArg('--client') || process.env.CF_ELECTRON_CLIENT;

// Auto-detect default paths if not provided
if (!frameworkPath) {
  frameworkPath = frameworkFolder; // Use current cf-electron folder
  console.log('‚ÑπÔ∏è  Using default framework path:', frameworkPath);
}

if (!clientPath) {
  clientPath = path.join(workspaceFolder, 'cf-2026');
  console.log('‚ÑπÔ∏è  Using default client path:', clientPath);
}

// Validate paths exist
if (!fs.existsSync(frameworkPath)) {
  console.error(`
‚ùå Framework path does not exist: ${frameworkPath}

Usage:
  node link-cf-electron.mjs --framework /path/to/cf-electron --client /path/to/cf-2026

Or via env:
  CF_ELECTRON_FRAMEWORK=/path/to/cf-electron
  CF_ELECTRON_CLIENT=/path/to/cf-2026

Or use default paths in workspace folder:
  - cf-electron (framework)
  - cf-2026 (client)
`);
  process.exit(1);
}

if (!fs.existsSync(clientPath)) {
  console.error(`
‚ùå Client path does not exist: ${clientPath}

Usage:
  node link-cf-electron.mjs --framework /path/to/cf-electron --client /path/to/cf-2026

Or via env:
  CF_ELECTRON_FRAMEWORK=/path/to/cf-electron
  CF_ELECTRON_CLIENT=/path/to/cf-2026

Or use default paths in workspace folder:
  - cf-electron (framework)
  - cf-2026 (client)
`);
  process.exit(1);
}

const framework = path.resolve(frameworkPath);
const client = path.resolve(clientPath);

const targetDir = path.join(
  client,
  'node_modules',
  '@creative-force'
);
const linkPath = path.join(targetDir, 'electron');

console.log('üîó Linking @creative-force/electron');
console.log('Framework:', framework);
console.log('Client:', client);

fs.mkdirSync(targetDir, { recursive: true });

if (fs.existsSync(linkPath)) {
  console.log('‚ö†Ô∏è Existing link found. Removing...');
  fs.rmSync(linkPath, { recursive: true, force: true });
}

fs.symlinkSync(framework, linkPath, 'dir');

console.log('‚úÖ Symlink created:');
console.log(linkPath);
</file>

<file path="scripts/unlink-cf-electron.mjs">
import fs from 'fs';
import path from 'path';
import process from 'process';

function getArg(name) {
  const index = process.argv.indexOf(name);
  return index !== -1 ? process.argv[index + 1] : null;
}

const clientPath =
  getArg('--client') || process.env.CF_ELECTRON_CLIENT;

if (!clientPath) {
  console.error(`
‚ùå Missing client path.

Usage:
  node unlink-electron.mjs --client /path/to/electron-vite-angular
`);
  process.exit(1);
}

const client = path.resolve(clientPath);
const linkPath = path.join(
  client,
  'node_modules',
  '@creative-force',
  'electron'
);

console.log('üßπ Removing @creative-force/electron symlink');

if (fs.existsSync(linkPath)) {
  fs.rmSync(linkPath, { recursive: true, force: true });
  console.log('‚úÖ Symlink removed');
} else {
  console.log('‚ÑπÔ∏è No symlink found');
}
</file>

<file path="scripts/zip-source.mjs">
import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';
import archiver from 'archiver';

function getArg(name) {
  const index = process.argv.indexOf(name);
  return index !== -1 ? process.argv[index + 1] : null;
}

// Get project root folder (parent directory of scripts folder)
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);
const projectRoot = path.resolve(__dirname, '..');

// Format date time for filename: YYYYMMDD-HHMMSS
function formatDateTime() {
  const now = new Date();
  const year = now.getFullYear();
  const month = String(now.getMonth() + 1).padStart(2, '0');
  const day = String(now.getDate()).padStart(2, '0');
  const hours = String(now.getHours()).padStart(2, '0');
  const minutes = String(now.getMinutes()).padStart(2, '0');
  const seconds = String(now.getSeconds()).padStart(2, '0');
  return `${year}${month}${day}-${hours}${minutes}${seconds}`;
}

// Get output path from args or use default
const customOutput = getArg('--output') || getArg('-o');
let zipPath;

if (customOutput) {
  // If custom output is provided, resolve it relative to project root if it's not absolute
  if (path.isAbsolute(customOutput)) {
    zipPath = customOutput;
  } else {
    zipPath = path.resolve(projectRoot, customOutput);
  }
} else {
  // Default: create zip file in project root
  zipPath = path.join(projectRoot, `cf-electron-${formatDateTime()}.zip`);
}

console.log('üì¶ Creating source code zip...');
console.log('Project root:', projectRoot);
console.log('Output file:', zipPath);

// Create output directory if needed
const outputDir = path.dirname(zipPath);
if (!fs.existsSync(outputDir)) {
  fs.mkdirSync(outputDir, { recursive: true });
}

// Remove existing zip if exists
if (fs.existsSync(zipPath)) {
  console.log('‚ö†Ô∏è  Removing existing zip file...');
  fs.unlinkSync(zipPath);
}

// Create zip archive
const output = fs.createWriteStream(zipPath);
const archive = archiver('zip', {
  zlib: { level: 9 }, // Maximum compression
});

output.on('close', () => {
  const sizeInMB = (archive.pointer() / 1024 / 1024).toFixed(2);
  console.log('‚úÖ Zip created successfully!');
  console.log(`üìä Total size: ${sizeInMB} MB`);
  console.log(`üìÅ File: ${zipPath}`);
});

archive.on('error', (err) => {
  console.error('‚ùå Error creating zip:', err);
  process.exit(1);
});

archive.on('warning', (err) => {
  if (err.code === 'ENOENT') {
    console.warn('‚ö†Ô∏è  Warning:', err);
  } else {
    throw err;
  }
});

archive.pipe(output);

// Files and directories to exclude
const excludeDirs = ['node_modules', 'dist', '.git'];
const excludeFiles = ['.DS_Store', '.eslintcache'];
const excludeExtensions = ['.log', '.zip'];

// Function to check if path should be excluded
function shouldExclude(filePath) {
  const relativePath = path.relative(projectRoot, filePath);
  const pathParts = relativePath.split(path.sep);
  const fileName = path.basename(filePath);

  // Check excluded directories
  for (const dir of excludeDirs) {
    if (pathParts.includes(dir)) {
      return true;
    }
  }

  // Check excluded file names
  for (const file of excludeFiles) {
    if (fileName === file || relativePath.includes(file)) {
      return true;
    }
  }

  // Check excluded file extensions
  for (const ext of excludeExtensions) {
    if (fileName.endsWith(ext) || relativePath.endsWith(ext)) {
      return true;
    }
  }

  return false;
}

// Add files to archive
function addDirectory(dirPath, archivePath = '') {
  const entries = fs.readdirSync(dirPath, { withFileTypes: true });

  for (const entry of entries) {
    const fullPath = path.join(dirPath, entry.name);
    const relativePath = path.join(archivePath, entry.name);

    // Skip excluded paths
    if (shouldExclude(fullPath)) {
      continue;
    }

    if (entry.isDirectory()) {
      addDirectory(fullPath, relativePath);
    } else if (entry.isFile()) {
      archive.file(fullPath, { name: relativePath });
    }
  }
}

// Start adding files
addDirectory(projectRoot);

// Finalize the archive
archive.finalize();
</file>

<file path="src/config/appConfigModule.ts">
import { ZodError, z } from 'zod';
import type { AppModule, AppContainer } from '../core/coreTypes';
import type { AppConfigInput } from './appConfigTypes';
import { AppConfigServiceImpl } from './appConfigService';

export class AppConfigModule<T> implements AppModule {
  constructor(private readonly input: AppConfigInput<T>) {}

  register(container: AppContainer) {
    const { schema, value } = this.input;

    try {
      const parsed = schema.parse(value);
      console.log('[config] parsed config', parsed);
      container
        .bind(AppConfigServiceImpl)
        .toConstantValue(new AppConfigServiceImpl(parsed as Readonly<T>));
    } catch (err) {
      if (err instanceof ZodError) {
        console.error('[config] invalid config', z.treeifyError(err));
      }
      throw new Error('Invalid application configuration');
    }
  }
}
</file>

<file path="src/config/appConfigService.ts">
export interface AppConfigService<T> {
    get(): Readonly<T>;
}

export class AppConfigServiceImpl<T> implements AppConfigService<T> {

    constructor(private readonly config: Readonly<T>) {
    }

    get(): Readonly<T> {
        return this.config;
    }
}
</file>

<file path="src/config/appConfigTypes.ts">
import { ZodType } from 'zod';

export interface AppConfigInput<T> {
    schema: ZodType<T>;
    value: unknown;
}
</file>

<file path="src/config/index.ts">
export * from './appConfigTypes';
export * from './appConfigService';
export { AppConfigModule } from './appConfigModule';
</file>

<file path="src/core/appLifecycle.ts">
import {app} from 'electron';
import { AppModule } from './coreTypes';

export async function startModules(modules: AppModule[]) {
    for (const module of modules) {
        if (module.start) {
            console.log(`[electron-core] Starting module ${module.constructor.name}`);
            await module.start();
        }
    }
};

export async function stopModules(modules: AppModule[]) {
    // reverse order to stop modules
    for (const module of modules.slice().reverse()) {
        if (module.stop) {
            console.log(`[electron-core] Stopping module ${module.constructor.name}`);
            await module.stop();
        }
    }
};

/**
 * Setup app lifecycle hooks
 * @param modules - The modules to setup lifecycle hooks for
 * @description - Setup app lifecycle hooks for the given modules. Stop modules in reverse order before app quit.    
 */
export function setupAppLifecycle(modules: AppModule[]) {
   app.on('before-quit', async (event) => {
    console.log(`[electron-core] App before quit`);
    event.preventDefault();
    try {
        await stopModules(modules);
    } catch (error) {
        console.error(`[electron-core] Error during shutdown' ${error}`);
    }
    finally {
        console.log(`[electron-core] App quitting`);
        app.exit(0);
    }
   });
};
</file>

<file path="src/core/coreTypes.ts">
import { Container } from "inversify";

export type AppContainer = Container;

export interface AppModule {
    /**
     * Register dependencies & handler
     * Called before Electron app ready
     */
    register(container: AppContainer): void;
    /**
     * Start the app
     * Called after Electron app ready
     */
    start?(): Promise<void>;
    /**
     * Stop the app
     * Called when app is quitting
     */
    stop?(): Promise<void>;
}

/**
 * Options for creating an Electron app
 */
export interface CreateAppOptions {
    appId: string;
    /**
     * The name of the app (optional). Fallback to appId if not provided
     * @default undefined
     */
    appName?: string;
    /**
     * The configuration for the app
     */
    config?: unknown;
    /**
     * The modules for the app
     */
    modules?: AppModule[];
}
</file>

<file path="src/core/createElectronApp.ts">
import { app } from 'electron';
import { createAppContainer } from '../di/container';
import { setupAppLifecycle, startModules } from './appLifecycle';
import { CreateAppOptions } from './coreTypes';


export async function createElectronApp(options: CreateAppOptions) {
   const {appId, modules = []} = options;
   if (!appId) {
    throw new Error('[electron-core] appId is required');
   }

   console.log(`[electron-core] Starting app ${appId}`);

   const container = createAppContainer();

   // Register modules (sync, before app ready)
   for (const module of modules) {
    try {
        console.log(`[electron-core] Registering module: ${module.constructor.name}`);
        module.register(container);
    } catch (error) {
        console.error(`[electron-core] Failed to register module: ${module.constructor.name}`, error);
        throw error;
    }
   }

   // Setup app lifecycle hooks
   setupAppLifecycle(modules);

   // Wait for app ready
   await app.whenReady();
   console.log(`[electron-core] App ready`);

   // Start modules (async, after app ready)
   try {
    await startModules(modules);
   } catch (error) {
    console.error(`[electron-core] Failed to start modules`, error);
    app.exit(1);
   }
};
</file>

<file path="src/di/container.ts">
import { Container } from 'inversify';

let container: Container | null = null;

/**
 * Create a new app container if not exists
 * Only one container is allowed per app
 * Not global mutable outside container
 * @returns {Container} The app container
 */
export function createAppContainer(): Container {
   if (!container) {
    container = new Container({
        defaultScope: 'Singleton',
        autoBindInjectable: false,
    });
   }
   return container;
};
</file>

<file path="src/ipc/ipcChannels.ts">
// Share across all modules

export type IPCDomain = 'app' 

export const IPC_CHANNELS = {
    APP_GET_VERSION: 'app:getVersion',
  } as const;
  
  export type IpcChannel =
    typeof IPC_CHANNELS[keyof typeof IPC_CHANNELS];
</file>

<file path="src/ipc/ipcHandlerRegistry.ts">
import { ipcMain } from 'electron';
import type { IpcChannel } from './ipcChannels';

type IpcHandler = (...args: any[]) => Promise<any>;

export class IpcRegistry {
    private registered = new Set<IpcChannel>();

    register(channel: IpcChannel, handler: IpcHandler) {
       if (this.registered.has(channel)) {
        throw new Error(`[ipc] Channel already registered: ${channel}`);
       }
       this.registered.add(channel);
       ipcMain.handle(channel, async (_event, ...args) => {
        try {
            return await handler(...args);
        } catch (error) {
            console.error(`[ipc] Handler error: ${channel}`, error);
            throw new Error('IPC_OPERATION_FAILED');
        }
       });
    }

    clear() {
        for (const channel of this.registered) {
            ipcMain.removeHandler(channel);
        }
        this.registered.clear();
    }
}
</file>

<file path="src/ipc/ipcMainModule.ts">
import type { AppModule, AppContainer } from '../core/coreTypes';
import { IpcRegistry } from './ipcHandlerRegistry';
import { IPC_CHANNELS } from './ipcChannels';
import { app } from 'electron';

export class IpcMainModule implements AppModule {
  private registry = new IpcRegistry();

  register(_: AppContainer) {
    // register IPC channels 
    // App domain
    this.registry.register(
      IPC_CHANNELS.APP_GET_VERSION,
      async () => app.getVersion()
    );
  }

  async stop() {
    this.registry.clear();
  }
}
</file>

<file path="src/preload/preloadApi.ts">
import { ipcRenderer } from 'electron';
import { IPC_CHANNELS } from '../ipc/ipcChannels';

export const api = {
  app: {
    getVersion(): Promise<string> {
      return ipcRenderer.invoke(IPC_CHANNELS.APP_GET_VERSION);
    }
  },
};
</file>

<file path="src/preload/preloadEntry.ts">
import { contextBridge } from 'electron';
import { api } from './preloadApi';

contextBridge.exposeInMainWorld('api', api);
</file>

<file path="src/window/index.ts">
// src/window/index.ts
export * from './windowTypes';
export { WindowMainModule } from './windowMainModule';
</file>

<file path="src/window/windowMainModule.ts">
// src/window/windowMainModule.ts
import { BrowserWindow } from 'electron';
import { join } from 'node:path';
import type { AppModule, AppContainer } from '../core/coreTypes';
import type { WindowOptions } from './windowTypes';

export class WindowMainModule implements AppModule {
  private mainWindow?: BrowserWindow;

  constructor(private readonly options: WindowOptions) {}

  register(_container: AppContainer) {
    // no-op for now
  }

  async start() {
    const {
      preloadPath,
      load,
      browserWindow = {}
    } = this.options;
    console.log('[window] starting window', this.options);
    this.mainWindow = new BrowserWindow({
      width: 1200,
      height: 800,
      show: false,
      webPreferences: {
        preload: preloadPath,
        contextIsolation: true,
        nodeIntegration: false,
        sandbox: true,
      },
      ...browserWindow
    });

    this.mainWindow.once('ready-to-show', () => {
      this.mainWindow?.show();
    });

    if (load.devUrl) {
      await this.mainWindow.loadURL(load.devUrl);
    } else if (load.prodFile) {
      await this.mainWindow.loadFile(load.prodFile);
    } else {
      throw new Error('[window] No renderer entry provided');
    }
  }

  async stop() {
    if (this.mainWindow && !this.mainWindow.isDestroyed()) {
      this.mainWindow.destroy();
    }
  }
}
</file>

<file path="src/window/windowTypes.ts">
// src/window/windowTypes.ts
export interface WindowOptions {
    preloadPath: string;
  
    load: {
      devUrl?: string;
      prodFile?: string;
    };
  
    browserWindow?: Electron.BrowserWindowConstructorOptions;
  }
</file>

<file path="src/index.ts">
import 'reflect-metadata';

// app
export { createElectronApp } from './core/createElectronApp';
export type { CreateAppOptions, AppModule, AppContainer } from './core/coreTypes';

// ipc
export { IpcMainModule } from './ipc/ipcMainModule';
export { IPC_CHANNELS } from './ipc/ipcChannels';

// config
export { AppConfigModule } from './config/appConfigModule';
export type { AppConfigInput } from './config/appConfigTypes';


// window
export * from './window';
</file>

<file path=".cursorrules">
# CF-Electron Framework - Cursor Instructions

## Project Overview
This is an internal Electron framework (`@creative-force/electron`) that serves as the foundation for Creative Force desktop applications. It standardizes Electron main process, module lifecycle, and provides dependency injection infrastructure.

## Documentation Location
All project documentation, engineering notes, and instructions are located in the `docs/` directory:

- `docs/README.md` - **Start here**: Index and guide to all documentation
- `docs/OVERVIEW.md` - High-level architecture, principles, and project structure
- `docs/MODULE-*.md` - Module-specific documentation and implementation notes
  - `docs/MODULE-0.1-NOTES.md` - App Bootstrap & Lifecycle module documentation

**IMPORTANT**: Always read relevant documentation in `docs/` before making changes or answering questions about the framework. Start with `docs/README.md` for an overview of available documentation.

## Key Principles
1. **Framework ‚â† App**: Framework manages lifecycle and infrastructure, apps only compose modules
2. **Clear Boundaries**: App doesn't call Electron lifecycle directly, doesn't know DI implementation details
3. **Module-based**: Everything is a module with `register()`, `start()`, and `stop()` lifecycle
4. **Dependency Injection**: Uses Inversify for DI container

## Architecture
- **Entry Point**: `src/index.ts` exports `createElectronApp()`
- **Core**: `src/app/` - App bootstrap, lifecycle management, types
- **DI**: `src/di/` - Dependency injection container setup
- **Build**: Vite builds to CommonJS in `dist/`

## Module Lifecycle
1. `createElectronApp()` is called
2. DI container is created
3. All modules call `register(container)` synchronously
4. Electron `app.whenReady()` fires
5. All modules call `start()` in order
6. On quit, modules call `stop()` in reverse order

## Development Guidelines
- Don't modify completed modules unless necessary
- Follow module documentation in `docs/` for new features
- Write docs alongside code
- New modules must be usable immediately with examples
- Maintain good DX (Developer Experience)

## When Answering Questions or Making Changes
1. **First**: Check `docs/README.md` for documentation index and navigation
2. **Then**: Check `docs/OVERVIEW.md` for architecture context
3. **Next**: Check relevant `docs/MODULE-*.md` for specific module details
4. **Finally**: Review source code in `src/` to understand implementation

Always reference documentation when explaining concepts or making architectural decisions.
</file>

<file path=".gitignore">
# Dependencies
node_modules/

# Build output
dist/
out/

# OS files
.DS_Store

# Logs
*.log*
.eslintcache

# Zip files
*.zip
</file>

<file path="NAMING-CONVENTIONS.md">
# NAMING-CONVENTIONS.md

## Purpose
This document defines **naming conventions** for the Creative Force Electron Framework.
The goal is to ensure:
- Long-term consistency
- Clear ownership boundaries (framework vs app)
- No future large-scale renaming
- Good Developer Experience (DX)
- Easy onboarding for developers and AI-assisted tooling

These rules are **frozen for v0.x ‚Üí v1** unless explicitly revised.

---

## 1. General Principles

1. Names must reflect **responsibility**, not implementation.
2. Names must make **ownership obvious** (framework vs app vs business).
3. Avoid generic names that become dumping grounds.
4. Prefer clarity over brevity.
5. Naming must scale to multi-app, multi-module scenarios.

---

## 2. Package Naming

**Format**
```
@creative-force/electron-<domain>
```

**Examples**
- @creative-force/electron-core
- @creative-force/electron-ipc
- @creative-force/electron-config
- @creative-force/electron-logger
- @creative-force/electron-services
- @creative-force/electron-auth

**Rules**
- One package = one clear responsibility
- No mixed domains in a single package
- Business-specific logic does NOT belong in framework packages

---

## 3. Folder Naming

**Rule**
- Folder name = **domain or layer (noun)**

**Good**
- core/
- ipc/
- config/
- preload/
- window/
- auth/
- services/
- logger/

**Avoid**
- app/ (ambiguous: framework app vs client app)
- types/ (too generic)
- utils/ (only allowed for truly generic helpers)

---

## 4. File Naming

**Rule**
```
<responsibility><Context>.ts
```

Context examples:
- Module
- Service
- Registry
- Types
- Entry
- Api

### Core
- createElectronApp.ts
- appLifecycle.ts
- coreTypes.ts

### IPC
- ipcChannels.ts
- ipcHandlerRegistry.ts
- ipcMainModule.ts
- ipcContracts.ts (request/response payload types)

### Config
- appConfigTypes.ts
- appConfigService.ts
- appConfigModule.ts

### Preload
- preloadEntry.ts
- preloadApi.ts
- preloadBridge.ts (if needed)

**Index files**
- index.ts is allowed ONLY to re-export public API
- index.ts must not contain logic

---

## 5. Class & Interface Naming

### Interfaces
- Use **role-based naming**
- Avoid implementation hints

**Examples**
- ElectronModule
- AppContainer
- AppConfigService<T>
- IpcHandlerRegistry

### Implementations
- Suffix with Impl or Default

**Examples**
- AppConfigServiceImpl
- DefaultAppConfigService

Avoid ambiguous names like:
- DefaultConfigService
- BaseService

---

## 6. IPC Channel Naming

**Rule**
```
<domain>:<action>
```

**Examples**
- app:getVersion
- auth:login
- task:downloadResource
- netcore:startService

**Rules**
- IPC strings must exist ONLY in ipcChannels.ts
- No string literals outside IPC contract files
- Domain represents business/domain, not module name
- Action is verb-based

---

## 7. Preload API Naming

**Rule**
```
window.api.<domain>.<action>()
```

**Examples**
- window.api.app.getVersion()
- window.api.auth.login()
- window.api.task.downloadResource(taskId)

**Hard rules**
- Renderer must not import Electron or IPC APIs
- Preload exposes ONE object: window.api
- No dynamic channel names
- No raw ipcRenderer exposure

---

## 8. Config Naming

**Rules**
- Config is always App-owned
- Config is read-only
- Schema name ends with Schema

**Examples**
- AppConfigSchema
- AppConfig
- AppConfigService

Framework must not define business config schemas.

---

## 9. Documentation Naming

**Rule**
```
MODULE-<phase>.<index>-<NAME>.md
```

**Examples**
- MODULE-0.1-NOTES.md
- MODULE-1.1-INSTRUCTIONS.md
- MODULE-1.2-INSTRUCTIONS.md

Always use plural INSTRUCTIONS for consistency.

---

## 10. Anti-patterns (Do Not Use)

- Generic folders like types/ or utils/
- String literal IPC channels
- Re-exporting third-party DSLs (e.g., zod)
- Naming tied to current implementation
- Abbreviations that reduce clarity

---

## 11. Enforcement

1. PR checklist must include:
   - Naming conventions followed
2. Major naming changes require:
   - Documentation update
   - Explicit review
3. Breaking naming changes require MAJOR version bump

---

## 12. Guiding Principle

> **Good naming is part of architecture, not a cosmetic choice.**

If a name is unclear today, it will become technical debt tomorrow.
</file>

<file path="package.json">
{
  "name": "@creative-force/electron",
  "version": "0.1.0",
  "private": false,
  "main": "dist/index.cjs",
  "types": "dist/index.d.ts",
  "scripts": {
    "build": "vite build",
    "build:watch": "vite build --watch",
    "prepublishOnly": "pnpm build",
    "link": "node scripts/link-cf-electron.mjs --client /Users/haht/Documents/Workspace/cf-2026 --framework /Users/haht/Documents/Workspace/cf-electron",
    "unlink": "node scripts/unlink-cf-electron.mjs --client /Users/haht/Documents/Workspace/cf-2026 --framework /Users/haht/Documents/Workspace/cf-electron",
    "zip": "node scripts/zip-source.mjs"
  },
  "files": [
    "dist",
    "README.md"
  ],
  "exports": {
    ".": {
      "require": "./dist/index.cjs",
      "types": "./dist/index.d.ts"
    }
  },
  "publishConfig": {
    "access": "restricted"
  },
  "dependencies": {
    "inversify": "^6.0.2",
    "reflect-metadata": "^0.2.2",
    "zod": "^4.2.1"
  },
  "devDependencies": {
    "archiver": "^7.0.1",
    "electron": "^39.2.6",
    "electron-builder": "^26.0.12",
    "electron-updater": "^6.3.9",
    "electron-vite": "^5.0.0",
    "typescript": "^5.9.3",
    "vite": "^7.2.6",
    "vite-plugin-dts": "^3.9.0"
  }
}
</file>

<file path="SESSION-CONTEXT-SUMMARY.md">
# SESSION-CONTEXT-SUMMARY.md

## 1. V·∫•n ƒë·ªÅ hi·ªán t·∫°i

Team Creative Force ƒëang qu·∫£n l√Ω **nhi·ªÅu desktop application (Electron)** ƒë·ªôc l·∫≠p:
- Kelvin
- Hue
- Luma
- Ink

C√°c app n√†y:
- D√πng **c√πng tech stack** (Electron + Angular + Node/.NET integration)
- C√≥ **r·∫•t nhi·ªÅu logic tr√πng l·∫∑p**:
  - IPC
  - preload
  - auth flow
  - config
  - service manager
  - window lifecycle
- M·ªói app l√† **repo ri√™ng bi·ªát**, d·∫´n t·ªõi:
  - Duplicate code
  - Naming kh√¥ng consistent
  - Fix bug / update lib ph·∫£i l√†m l·∫°i nhi·ªÅu l·∫ßn
  - Kh√≥ maintain, kh√≥ onboard dev m·ªõi
  - Kh√≥ ƒë·∫£m b·∫£o security baseline ƒë·ªìng nh·∫•t

‚û°Ô∏è V·ªõi ngu·ªìn l·ª±c hi·ªán t·∫°i, c√°ch l√†m n√†y **kh√¥ng scale ƒë∆∞·ª£c**.

---

## 2. L√Ω do c·∫ßn Internal Electron Framework

M·ª•c ti√™u c·ªßa vi·ªác x√¢y d·ª±ng **internal Electron framework**:

### 2.1 Chu·∫©n h√≥a (Standardization)
- Chu·∫©n h√≥a:
  - App lifecycle
  - IPC & preload
  - Config management
  - Window creation
  - Naming conventions
- M·ªçi app ƒë·ªÅu follow c√πng pattern ‚Üí d·ªÖ ƒë·ªçc, d·ªÖ debug.

### 2.2 T√°i s·ª≠ d·ª•ng (Reuse)
- C√°c app d√πng chung:
  - Framework core
  - Infrastructure modules
- Business logic n·∫±m ·ªü app ho·∫∑c module ri√™ng.

### 2.3 Gi·∫£m chi ph√≠ ph√°t tri·ªÉn
- Implement feature 1 l·∫ßn ‚Üí d√πng cho nhi·ªÅu app
- Fix bug / update dependency t·∫≠p trung
- D·ªÖ test & rollout

### 2.4 Chu·∫©n b·ªã cho t∆∞∆°ng lai
- G·ªôp Hue / Luma / Ink th√†nh app beta
- D·ªÖ m·ªü r·ªông:
  - Auth
  - Logger
  - Service manager
  - Background tasks
- Ph√π h·ª£p AI-assisted development

---

## 3. Tri·∫øt l√Ω thi·∫øt k·∫ø Framework

### 3.1 Framework ‚â† App
- Framework **kh√¥ng ch·ª©a business logic**
- Framework ch·ªâ cung c·∫•p:
  - Infrastructure
  - Guardrails
  - Contracts

### 3.2 Module-based
- Framework ƒë∆∞·ª£c chia th√†nh **c√°c module ƒë·ªôc l·∫≠p**
- App compose module theo nhu c·∫ßu
- Kh√¥ng over-engineer

### 3.3 Fail fast & secure by default
- Config invalid ‚Üí app kh√¥ng start
- Preload & IPC theo security checklist
- Kh√¥ng expose Electron API cho renderer

---

## 4. T·ªïng quan Structure Framework ƒë√£ implement

### 4.1 Phase & Module strategy

Framework ƒë∆∞·ª£c x√¢y theo **phase** (kh√¥ng ph·∫£i semver):

| Phase | √ù nghƒ©a |
|-----|--------|
| 0.x | Foundation |
| 1.x | Communication & Control |
| 2.x | Infrastructure |
| 3.x | Feature foundation |

---

### 4.2 Module ƒë√£ implement

#### Module 0.1 ‚Äì App Bootstrap
**M·ª•c ti√™u**
- Chu·∫©n h√≥a lifecycle Electron app
- DI container
- Module lifecycle (register / start / stop)

**Th√†nh ph·∫ßn ch√≠nh**
- `createElectronApp`
- `ElectronModule`
- `AppContainer`

---

#### Module 1.1 ‚Äì IPC (Request / Response)
**M·ª•c ti√™u**
- Chu·∫©n h√≥a communication gi·ªØa main ‚Üî renderer
- IPC centralized
- Kh√¥ng string literal

**Th√†nh ph·∫ßn**
- IPC channel contracts
- IPC handler registry
- Preload API wrapper

---

#### Module 1.2 ‚Äì Configuration Management
**M·ª•c ti√™u**
- Typed, validated config
- Fail fast
- App-owned schema

**Th√†nh ph·∫ßn**
- `AppConfigModule`
- `AppConfigService`
- Zod-based validation
- Config injected qua DI

---

#### Module 1.3 ‚Äì Window
**M·ª•c ti√™u**
- T·∫°o BrowserWindow chu·∫©n
- G·∫Øn preload
- Load renderer dev/prod
- Security baseline

**Th√†nh ph·∫ßn**
- `WindowMainModule`
- `WindowOptions`
- Preload entry & API

---

### 4.3 Naming Conventions
- ƒê√£ freeze naming rules trong `NAMING-CONVENTIONS.md`
- √Åp d·ª•ng cho:
  - Folder
  - File
  - Class / interface
  - IPC channel
  - Preload API
  - Documentation

---

## 5. K·∫øt qu·∫£ hi·ªán t·∫°i

Sau Phase 1 (0.1 ‚Üí 1.3):
- Framework **ƒë·ªß ƒë·ªÉ ch·∫°y app th·∫≠t**
- C√≥ th·ªÉ build:
  - App demo
  - App beta (Auth-only)
- Ki·∫øn tr√∫c r√µ r√†ng, kh√¥ng over-engineer
- S·∫µn s√†ng m·ªü r·ªông Phase 2

---

## 6. H∆∞·ªõng ti·∫øp theo (Planned)

### Phase 2 ‚Äì Infrastructure
- Logger module
- Service Manager (netcore services)
- Background task runner

### Phase 3 ‚Äì Feature Foundation
- Auth (OAuth PKCE)
- Common business modules

### Documentation
- Build documentation website:
  - Framework docs
  - App beta docs
- Onboarding & reference cho dev

---

## Guiding Principle

> **Standardization reduces cost.  
> Framework provides guardrails.  
> Business logic stays in the app.**
</file>

<file path="tsconfig.json">
{
    "compilerOptions": {
      "target": "ES2020",
      "module": "commonjs",
      "declaration": true,
      "outDir": "dist",
      "rootDir": "src",
      "strict": true
    },
    "include": ["src"]
  }
</file>

<file path="vite.config.ts">
import { defineConfig } from 'vite';
import dts from 'vite-plugin-dts';

export default defineConfig({
  build: {
    lib: {
      entry: 'src/index.ts',
      formats: ['cjs'],
      fileName: () => 'index.cjs'
    },
    target: 'node18',
    outDir: 'dist',
    emptyOutDir: true,
    rollupOptions: {
      external: [
        'electron',
        'inversify',
        'reflect-metadata'
      ]
    }
  },
  plugins: [dts()]
});
</file>

</files>
