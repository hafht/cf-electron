"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});require("reflect-metadata");const f=require("electron"),E=require("inversify");let g=null;function v(){return g||(g=new E.Container({defaultScope:"Singleton",autoBindInjectable:!1})),g}async function P(t){for(const e of t)e.start&&(console.log(`[electron-core] Starting module ${e.constructor.name}`),await e.start())}async function S(t){for(const e of t.slice().reverse())e.stop&&(console.log(`[electron-core] Stopping module ${e.constructor.name}`),await e.stop())}function O(t){f.app.on("before-quit",async e=>{console.log("[electron-core] App before quit"),e.preventDefault();try{await S(t)}catch(r){console.error(`[electron-core] Error during shutdown' ${r}`)}finally{console.log("[electron-core] App quitting"),f.app.exit(0)}})}async function I(t){const{appId:e,modules:r=[]}=t;if(!e)throw new Error("[electron-core] appId is required");console.log(`[electron-core] Starting app ${e}`);const o=v();for(const s of r)try{console.log(`[electron-core] Registering module: ${s.constructor.name}`),s.register(o)}catch(i){throw console.error(`[electron-core] Failed to register module: ${s.constructor.name}`,i),i}O(r),await f.app.whenReady(),console.log("[electron-core] App ready");try{await P(r)}catch(s){console.error("[electron-core] Failed to start modules",s),f.app.exit(1)}}class j{constructor(){this.registered=new Set}register(e,r){if(this.registered.has(e))throw new Error(`[ipc] Channel already registered: ${e}`);this.registered.add(e),f.ipcMain.handle(e,async(o,...s)=>{try{return await r(...s)}catch(i){throw console.error(`[ipc] Handler error: ${e}`,i),new Error("IPC_OPERATION_FAILED")}})}clear(){for(const e of this.registered)f.ipcMain.removeHandler(e);this.registered.clear()}}const m={APP_GET_VERSION:"app:getVersion"};class ${constructor(){this.registry=new j}register(e){this.registry.register(m.APP_GET_VERSION,async()=>f.app.getVersion())}async stop(){this.registry.clear()}}function b(t,e,r){function o(a,n){if(a._zod||Object.defineProperty(a,"_zod",{value:{def:n,constr:c,traits:new Set},enumerable:!1}),a._zod.traits.has(t))return;a._zod.traits.add(t),e(a,n);const u=c.prototype,l=Object.keys(u);for(let p=0;p<l.length;p++){const d=l[p];d in a||(a[d]=u[d].bind(a))}}const s=r?.Parent??Object;class i extends s{}Object.defineProperty(i,"name",{value:t});function c(a){var n;const u=r?.Parent?new i:this;o(u,a),(n=u._zod).deferred??(n.deferred=[]);for(const l of u._zod.deferred)l();return u}return Object.defineProperty(c,"init",{value:o}),Object.defineProperty(c,Symbol.hasInstance,{value:a=>r?.Parent&&a instanceof r.Parent?!0:a?._zod?.traits?.has(t)}),Object.defineProperty(c,"name",{value:t}),c}function h(t,e){return typeof e=="bigint"?e.toString():e}const z=(t,e)=>{t.name="$ZodError",Object.defineProperty(t,"_zod",{value:t._zod,enumerable:!1}),Object.defineProperty(t,"issues",{value:e,enumerable:!1}),t.message=JSON.stringify(e,h,2),Object.defineProperty(t,"toString",{value:()=>t.message,enumerable:!1})},A=b("$ZodError",z);function M(t,e=r=>r.message){const r={},o=[];for(const s of t.issues)s.path.length>0?(r[s.path[0]]=r[s.path[0]]||[],r[s.path[0]].push(e(s))):o.push(e(s));return{formErrors:o,fieldErrors:r}}function C(t,e=r=>r.message){const r={_errors:[]},o=s=>{for(const i of s.issues)if(i.code==="invalid_union"&&i.errors.length)i.errors.map(c=>o({issues:c}));else if(i.code==="invalid_key")o({issues:i.issues});else if(i.code==="invalid_element")o({issues:i.issues});else if(i.path.length===0)r._errors.push(e(i));else{let c=r,a=0;for(;a<i.path.length;){const n=i.path[a];a===i.path.length-1?(c[n]=c[n]||{_errors:[]},c[n]._errors.push(e(i))):c[n]=c[n]||{_errors:[]},c=c[n],a++}}};return o(t),r}function N(t,e=r=>r.message){const r={errors:[]},o=(s,i=[])=>{var c,a;for(const n of s.issues)if(n.code==="invalid_union"&&n.errors.length)n.errors.map(u=>o({issues:u},n.path));else if(n.code==="invalid_key")o({issues:n.issues},n.path);else if(n.code==="invalid_element")o({issues:n.issues},n.path);else{const u=[...i,...n.path];if(u.length===0){r.errors.push(e(n));continue}let l=r,p=0;for(;p<u.length;){const d=u[p],w=p===u.length-1;typeof d=="string"?(l.properties??(l.properties={}),(c=l.properties)[d]??(c[d]={errors:[]}),l=l.properties[d]):(l.items??(l.items=[]),(a=l.items)[d]??(a[d]={errors:[]}),l=l.items[d]),w&&l.errors.push(e(n)),p++}}};return o(t),r}var _;class R{constructor(){this._map=new WeakMap,this._idmap=new Map}add(e,...r){const o=r[0];if(this._map.set(e,o),o&&typeof o=="object"&&"id"in o){if(this._idmap.has(o.id))throw new Error(`ID ${o.id} already exists in the registry`);this._idmap.set(o.id,e)}return this}clear(){return this._map=new WeakMap,this._idmap=new Map,this}remove(e){const r=this._map.get(e);return r&&typeof r=="object"&&"id"in r&&this._idmap.delete(r.id),this._map.delete(e),this}get(e){const r=e._zod.parent;if(r){const o={...this.get(r)??{}};delete o.id;const s={...o,...this._map.get(e)};return Object.keys(s).length?s:void 0}return this._map.get(e)}has(e){return this._map.has(e)}}function k(){return new R}(_=globalThis).__zod_globalRegistry??(_.__zod_globalRegistry=k());const q=(t,e)=>{A.init(t,e),t.name="ZodError",Object.defineProperties(t,{format:{value:r=>C(t,r)},flatten:{value:r=>M(t,r)},addIssue:{value:r=>{t.issues.push(r),t.message=JSON.stringify(t.issues,h,2)}},addIssues:{value:r=>{t.issues.push(...r),t.message=JSON.stringify(t.issues,h,2)}},isEmpty:{get(){return t.issues.length===0}}})},Z=b("ZodError",q);class y{constructor(e){this.config=e}get(){return this.config}}class D{constructor(e){this.input=e}register(e){const{schema:r,value:o}=this.input;try{const s=r.parse(o);console.log("[config] parsed config",s),e.bind(y).toConstantValue(new y(s))}catch(s){throw s instanceof Z&&console.error("[config] invalid config",N(s)),new Error("Invalid application configuration")}}}exports.ConfigModule=D;exports.IPC_CHANNELS=m;exports.IpcModule=$;exports.createElectronApp=I;
